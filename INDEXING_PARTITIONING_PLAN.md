# CDC Tables - Indexing & Partitioning Plan

## Overview

This document outlines the plan to enhance CDC tables with:
- ✅ **Partitioning** by creation date (monthly intervals)
- ✅ **NOT NULL constraints** on partition columns
- ✅ **Indexes** on business keys (CALL_ID, SUBSCRIBER_NO, CUSTOMER_ID)

---

## Benefits

| Feature | Benefit |
|---------|---------|
| **Monthly Partitioning** | Queries scan only relevant months, faster performance |
| **NOT NULL on Dates** | Ensures data integrity, required for partitioning |
| **Business Key Indexes** | Fast lookups by CALL_ID, SUBSCRIBER_NO, CUSTOMER_ID |
| **LOCAL Indexes** | Partition-aware indexes, better performance on large tables |
| **Auto Partition Creation** | Oracle creates new partitions automatically each month |

---

## Table 1: CDC_PROCESSING_STATUS

### Current Structure
```sql
CREATE TABLE CDC_PROCESSING_STATUS (
    TABLE_NAME VARCHAR2(100) PRIMARY KEY,
    LAST_PROCESSED_TIMESTAMP TIMESTAMP,
    LAST_CHANGE_ID NUMBER,
    TOTAL_PROCESSED NUMBER DEFAULT 0,
    IS_ENABLED NUMBER DEFAULT 1,
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP,
    LAST_UPDATED TIMESTAMP DEFAULT SYSTIMESTAMP
)
```

### Enhanced Structure
```sql
CREATE TABLE CDC_PROCESSING_STATUS (
    TABLE_NAME VARCHAR2(100) NOT NULL,
    LAST_PROCESSED_TIMESTAMP TIMESTAMP,
    LAST_CHANGE_ID NUMBER,
    TOTAL_PROCESSED NUMBER DEFAULT 0,
    IS_ENABLED NUMBER DEFAULT 1,
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    LAST_UPDATED TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT PK_CDC_PROCESSING_STATUS PRIMARY KEY (TABLE_NAME)
)
PARTITION BY RANGE (CREATED_AT) INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
(
    PARTITION P_INITIAL VALUES LESS THAN (TIMESTAMP '2025-02-01 00:00:00')
);
```

### Changes
- ✅ Partition by `CREATED_AT` (monthly)
- ✅ `CREATED_AT` set to NOT NULL
- ✅ No additional indexes needed (small table, PK sufficient)

---

## Table 2: CDC_PROCESSED_CALLS

### Current Structure
```sql
CREATE TABLE CDC_PROCESSED_CALLS (
    CALL_ID VARCHAR2(50) PRIMARY KEY,
    PROCESSED_AT TIMESTAMP DEFAULT SYSTIMESTAMP,
    TEXT_TIME TIMESTAMP,
    SQS_MESSAGE_ID VARCHAR2(200)
)
```

### Enhanced Structure
```sql
CREATE TABLE CDC_PROCESSED_CALLS (
    CALL_ID VARCHAR2(50) NOT NULL,
    PROCESSED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    TEXT_TIME TIMESTAMP,
    SQS_MESSAGE_ID VARCHAR2(200),
    CONSTRAINT PK_CDC_PROCESSED_CALLS PRIMARY KEY (CALL_ID)
)
PARTITION BY RANGE (PROCESSED_AT) INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
(
    PARTITION P_INITIAL VALUES LESS THAN (TIMESTAMP '2025-02-01 00:00:00')
);
```

### Indexes
```sql
-- CALL_ID already indexed via PRIMARY KEY ✓
-- No additional indexes needed for this table
```

### Changes
- ✅ Partition by `PROCESSED_AT` (monthly)
- ✅ `PROCESSED_AT` set to NOT NULL
- ✅ CALL_ID already has PK index

---

## Table 3: CDC_PROCESSING_LOG

### Current Structure
```sql
CREATE TABLE CDC_PROCESSING_LOG (
    LOG_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    BATCH_ID VARCHAR2(50),
    CALL_ID VARCHAR2(50),
    OPERATION_TYPE VARCHAR2(20),
    PROCESSING_TIME_MS NUMBER,
    STATUS VARCHAR2(50),
    ERROR_MESSAGE CLOB,
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP
)
```

### Enhanced Structure
```sql
CREATE TABLE CDC_PROCESSING_LOG (
    LOG_ID NUMBER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    BATCH_ID VARCHAR2(50),
    CALL_ID VARCHAR2(50),
    OPERATION_TYPE VARCHAR2(20),
    PROCESSING_TIME_MS NUMBER,
    STATUS VARCHAR2(50),
    ERROR_MESSAGE CLOB,
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT PK_CDC_PROCESSING_LOG PRIMARY KEY (LOG_ID)
)
PARTITION BY RANGE (CREATED_AT) INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
(
    PARTITION P_INITIAL VALUES LESS THAN (TIMESTAMP '2025-02-01 00:00:00')
);
```

### Indexes
```sql
-- Index 1: CALL_ID (for call lookup in logs)
CREATE INDEX IDX_CDC_LOG_CALL_ID
ON CDC_PROCESSING_LOG(CALL_ID) LOCAL;

-- Index 2: BATCH_ID (for batch tracking)
CREATE INDEX IDX_CDC_LOG_BATCH_ID
ON CDC_PROCESSING_LOG(BATCH_ID) LOCAL;

-- Index 3: CREATED_AT (for temporal queries)
CREATE INDEX IDX_CDC_LOG_CREATED_AT
ON CDC_PROCESSING_LOG(CREATED_AT) LOCAL;
```

### Changes
- ✅ Partition by `CREATED_AT` (monthly)
- ✅ `CREATED_AT` set to NOT NULL
- ✅ 3 new indexes: CALL_ID, BATCH_ID, CREATED_AT

---

## Table 4: ERROR_LOG

### Current Structure
```sql
CREATE TABLE ERROR_LOG (
    ERROR_ID RAW(16) DEFAULT SYS_GUID() PRIMARY KEY,
    CALL_ID VARCHAR2(50),
    ERROR_MESSAGE CLOB,
    ERROR_TYPE VARCHAR2(100),
    RETRY_COUNT NUMBER DEFAULT 0,
    ERROR_TIMESTAMP TIMESTAMP DEFAULT SYSTIMESTAMP
)
```

### Enhanced Structure
```sql
CREATE TABLE ERROR_LOG (
    ERROR_ID RAW(16) DEFAULT SYS_GUID() NOT NULL,
    CALL_ID VARCHAR2(50),
    ERROR_MESSAGE CLOB,
    ERROR_TYPE VARCHAR2(100),
    RETRY_COUNT NUMBER DEFAULT 0,
    ERROR_TIMESTAMP TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT PK_ERROR_LOG PRIMARY KEY (ERROR_ID)
)
PARTITION BY RANGE (ERROR_TIMESTAMP) INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
(
    PARTITION P_INITIAL VALUES LESS THAN (TIMESTAMP '2025-02-01 00:00:00')
);
```

### Indexes
```sql
-- Index 1: CALL_ID (to find all errors for a specific call)
CREATE INDEX IDX_ERROR_LOG_CALL_ID
ON ERROR_LOG(CALL_ID) LOCAL;

-- Index 2: ERROR_TYPE (to filter by error category)
CREATE INDEX IDX_ERROR_LOG_ERROR_TYPE
ON ERROR_LOG(ERROR_TYPE) LOCAL;

-- Index 3: ERROR_TIMESTAMP (for temporal queries)
CREATE INDEX IDX_ERROR_LOG_TIMESTAMP
ON ERROR_LOG(ERROR_TIMESTAMP) LOCAL;
```

### Changes
- ✅ Partition by `ERROR_TIMESTAMP` (monthly)
- ✅ `ERROR_TIMESTAMP` set to NOT NULL
- ✅ 3 new indexes: CALL_ID, ERROR_TYPE, ERROR_TIMESTAMP

---

## Table 5: SQS_PERMANENT_FAILURES

### Current Structure
```sql
CREATE TABLE SQS_PERMANENT_FAILURES (
    FAILURE_ID RAW(16) DEFAULT SYS_GUID() PRIMARY KEY,
    CALL_ID VARCHAR2(50),
    ERROR_MESSAGE CLOB,
    TOTAL_ATTEMPTS NUMBER,
    ORIGINAL_MESSAGE CLOB,
    MARKED_FAILED_AT TIMESTAMP DEFAULT SYSTIMESTAMP
)
```

### Enhanced Structure
```sql
CREATE TABLE SQS_PERMANENT_FAILURES (
    FAILURE_ID RAW(16) DEFAULT SYS_GUID() NOT NULL,
    CALL_ID VARCHAR2(50),
    ERROR_MESSAGE CLOB,
    TOTAL_ATTEMPTS NUMBER,
    ORIGINAL_MESSAGE CLOB,
    MARKED_FAILED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT PK_SQS_PERMANENT_FAILURES PRIMARY KEY (FAILURE_ID)
)
PARTITION BY RANGE (MARKED_FAILED_AT) INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
(
    PARTITION P_INITIAL VALUES LESS THAN (TIMESTAMP '2025-02-01 00:00:00')
);
```

### Indexes
```sql
-- Index 1: CALL_ID (to find failed calls)
CREATE INDEX IDX_SQS_FAILURES_CALL_ID
ON SQS_PERMANENT_FAILURES(CALL_ID) LOCAL;

-- Index 2: MARKED_FAILED_AT (for temporal queries)
CREATE INDEX IDX_SQS_FAILURES_MARKED_AT
ON SQS_PERMANENT_FAILURES(MARKED_FAILED_AT) LOCAL;
```

### Changes
- ✅ Partition by `MARKED_FAILED_AT` (monthly)
- ✅ `MARKED_FAILED_AT` set to NOT NULL
- ✅ 2 new indexes: CALL_ID, MARKED_FAILED_AT

---

## Table 6: DICTA_CALL_SUMMARY

### Current Structure
```sql
CREATE TABLE DICTA_CALL_SUMMARY (
    CALL_ID VARCHAR2(50) PRIMARY KEY,
    CUSTOMER_ID VARCHAR2(50),
    SUBSCRIBER_NO VARCHAR2(50),
    CALL_TIME TIMESTAMP,
    SUMMARY_TEXT CLOB,
    SENTIMENT VARCHAR2(50),
    CLASSIFICATION_PRIMARY VARCHAR2(255),
    CLASSIFICATION_ALL CLOB,
    CONFIDENCE_SCORE NUMBER(5,2),
    ML_PROCESSING_TIME_MS NUMBER,
    ML_MODEL_VERSION VARCHAR2(50),
    PROCESSED_AT TIMESTAMP DEFAULT SYSTIMESTAMP
)
```

### Enhanced Structure
```sql
CREATE TABLE DICTA_CALL_SUMMARY (
    CALL_ID VARCHAR2(50) NOT NULL,
    CUSTOMER_ID VARCHAR2(50),
    SUBSCRIBER_NO VARCHAR2(50),
    CALL_TIME TIMESTAMP,
    SUMMARY_TEXT CLOB,
    SENTIMENT VARCHAR2(50),
    CLASSIFICATION_PRIMARY VARCHAR2(255),
    CLASSIFICATION_ALL CLOB,
    CONFIDENCE_SCORE NUMBER(5,2),
    ML_PROCESSING_TIME_MS NUMBER,
    ML_MODEL_VERSION VARCHAR2(50),
    PROCESSED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT PK_DICTA_CALL_SUMMARY PRIMARY KEY (CALL_ID)
)
PARTITION BY RANGE (PROCESSED_AT) INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
(
    PARTITION P_INITIAL VALUES LESS THAN (TIMESTAMP '2025-02-01 00:00:00')
);
```

### Indexes
```sql
-- CALL_ID already indexed via PRIMARY KEY ✓

-- Index 1: SUBSCRIBER_NO (phone number lookup)
CREATE INDEX IDX_DICTA_SUBSCRIBER_NO
ON DICTA_CALL_SUMMARY(SUBSCRIBER_NO) LOCAL;

-- Index 2: CUSTOMER_ID (customer account lookup)
CREATE INDEX IDX_DICTA_CUSTOMER_ID
ON DICTA_CALL_SUMMARY(CUSTOMER_ID) LOCAL;

-- Index 3: CALL_TIME (temporal queries on call time)
CREATE INDEX IDX_DICTA_CALL_TIME
ON DICTA_CALL_SUMMARY(CALL_TIME) LOCAL;

-- Index 4: PROCESSED_AT (temporal queries on processing time)
CREATE INDEX IDX_DICTA_PROCESSED_AT
ON DICTA_CALL_SUMMARY(PROCESSED_AT) LOCAL;
```

### Changes
- ✅ Partition by `PROCESSED_AT` (monthly)
- ✅ `PROCESSED_AT` set to NOT NULL
- ✅ 4 new indexes: SUBSCRIBER_NO, CUSTOMER_ID, CALL_TIME, PROCESSED_AT

---

## Summary of All Changes

### Partitioning
| Table | Partition Column | Interval |
|-------|------------------|----------|
| CDC_PROCESSING_STATUS | CREATED_AT | Monthly |
| CDC_PROCESSED_CALLS | PROCESSED_AT | Monthly |
| CDC_PROCESSING_LOG | CREATED_AT | Monthly |
| ERROR_LOG | ERROR_TIMESTAMP | Monthly |
| SQS_PERMANENT_FAILURES | MARKED_FAILED_AT | Monthly |
| DICTA_CALL_SUMMARY | PROCESSED_AT | Monthly |

### Indexes Summary
| Table | New Indexes | Total Indexes |
|-------|-------------|---------------|
| CDC_PROCESSING_STATUS | 0 | 1 (PK only) |
| CDC_PROCESSED_CALLS | 0 | 1 (PK only) |
| CDC_PROCESSING_LOG | 3 | 4 (PK + 3 indexes) |
| ERROR_LOG | 3 | 4 (PK + 3 indexes) |
| SQS_PERMANENT_FAILURES | 2 | 3 (PK + 2 indexes) |
| DICTA_CALL_SUMMARY | 4 | 5 (PK + 4 indexes) |
| **TOTAL** | **12 new indexes** | **18 total indexes** |

### NOT NULL Constraints Added
- All partition columns (6 columns)
- All primary key columns (6 columns)

---

## Implementation Steps

1. **Backup existing tables** (if they have data)
2. **Drop existing tables** (or use ALTER if possible - but partitioning requires recreate)
3. **Create new tables** with partition definitions
4. **Create indexes** after table creation
5. **Re-import data** (if any existed)
6. **Verify partitions** are created correctly
7. **Test queries** to ensure indexes are used

---

## Verification Queries

### Check Partitions
```sql
-- View all partitions for a table
SELECT table_name, partition_name, high_value, num_rows
FROM user_tab_partitions
WHERE table_name = 'CDC_PROCESSED_CALLS'
ORDER BY partition_position;
```

### Check Indexes
```sql
-- View all indexes for a table
SELECT index_name, index_type, uniqueness, locality
FROM user_indexes
WHERE table_name = 'CDC_PROCESSED_CALLS';

-- View index columns
SELECT index_name, column_name, column_position
FROM user_ind_columns
WHERE table_name = 'CDC_PROCESSED_CALLS'
ORDER BY index_name, column_position;
```

### Check Index Usage
```sql
-- Enable tracing to see if indexes are used
EXPLAIN PLAN FOR
SELECT * FROM CDC_PROCESSED_CALLS WHERE CALL_ID = '12345';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## Performance Expectations

### Before (No Partitions/Indexes)
- Full table scan on large tables
- Slow queries as data grows
- No easy archival strategy

### After (With Partitions/Indexes)
- Partition pruning (scan only relevant months)
- Index seeks instead of table scans
- Easy archival (drop old partitions)
- 10-100x faster queries on large datasets

---

## Maintenance

### Monthly
- Verify new partitions auto-created
- Check index statistics

### Quarterly
- Compress old partitions: `ALTER TABLE table_name MODIFY PARTITION partition_name COMPRESS;`
- Gather statistics: `EXEC DBMS_STATS.GATHER_TABLE_STATS('schema', 'table_name');`

### Yearly
- Drop partitions older than retention period
- Archive old data if needed

---

## Notes

- **INTERVAL partitioning**: Oracle automatically creates new partitions each month
- **LOCAL indexes**: Each partition has its own index segment (better performance)
- **NOT NULL required**: Partition columns must be NOT NULL
- **Existing data**: If tables have existing data, export before recreating tables

---

**Version**: 1.0
**Date**: 2025-10-23
**Status**: Planning Phase
